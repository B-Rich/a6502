; C'mon, the Compact MONitor
; written by Bruce Clark and placed in the public domain
;
; minor tweaks and porting by Ed Spittles
;
; To the extent possible under law, the owners have waived all
; copyright and related or neighboring rights to this work. 
;
; retrieved from http://www.lowkey.comuf.com/cmon.htm
;
; ported to ca65 from dev65 assembler
; /opt/cc65/bin/ca65 --listing --feature labels_without_colons cmon.a65 
; /opt/cc65/bin/ld65 -t none -o cmon.bin cmon.o
;
; ported to 6502 from 65Org16
; ported to a6502 emulator

       .org $ff26 ; adjusted to place reset vector correctly

init:

WIDTH  = 8         ;must be a power of 2
HEIGHT = 16

;INPUT  = $7F86
;OUTPUT = $7F83

.macro putc
       .byte $42,0      ; JSR OUTPUT
.endmacro

.macro getc
       .byte $42,1      ; JSR INPUT
.endmacro

ADRESS = 0
NUMBER = 2

MON    CLD
M1     JSR OUTCR
       LDA #$2D       ;output dash prompt
       putc
M2     LDA #0
       STA NUMBER+1
       STA NUMBER
M3     AND #$0F
M4     LDY #4         ;accumulate digit
M5     ASL NUMBER
       ROL NUMBER+1
       DEY
       BNE M5
       ORA NUMBER
       STA NUMBER
M6     getc
       CMP #$0D
       BEQ M1         ;branch if cr
;
; Insert additional commands for characters (e.g. control characters)
; outside the range $20 (space) to $7E (tilde) here
;
       CMP #$20       ;don't output if outside $20-$7E
       BCC M6
       CMP #$7F
       BCS M6
       putc
       CMP #$2C
       BEQ COMMA
       CMP #$40
       BEQ AT
;
; Insert additional commands for non-letter characters (or case-sensitive
; letters) here
;
       EOR #$30
       CMP #$0A
       BCC M4         ;branch if digit
       ORA #$20       ;convert to upper case
       SBC #$77
;
; mapping:
;   A-F -> $FFFA-$FFFF
;   G-O -> $0000-$0008
;   P-Z -> $FFE9-$FFF3
;
       BEQ GO
       CMP #-6 ; #$FA or #$FFFA
       BCS M3
;
; Insert additional commands for (case-insensitive) letters here
;
       CMP #-15 ; #$F1 or  #$FFF1
       BNE M6
DUMP   JSR OUTCR
       TYA
       PHA
       CLC            ;output address
       ADC NUMBER
       PHA
       LDA #0
       ADC NUMBER+1
       JSR OUTHEX
       PLA
       JSR OUTHSP
D1     LDA (NUMBER),Y ;output hex bytes
       JSR OUTHSP
       INY
       TYA
       AND #WIDTH-1
       BNE D1
       PLA
       TAY
D2     LDA (NUMBER),Y ;output characters
       AND #$7F
       CMP #$20
       BCC D3
       CMP #$7F
       BCC D4
D3     EOR #$40
D4     putc
       INY
       TYA
       AND #WIDTH-1
       BNE D2
       CPY #WIDTH*HEIGHT
       BCC DUMP
M2J
       JMP M2		; branches out of range for 6502 when putc is 3 bytes
COMMA  LDA NUMBER
       STA (ADRESS),Y
       INC ADRESS
       BNE M2J
       INC ADRESS+1
       BCS M2J
AT     LDA NUMBER
       STA ADRESS
       LDA NUMBER+1
       STA ADRESS+1
       BCS M2J
GO     JSR G1
       JMP MON
G1     JMP (NUMBER)
OUTHEX ;JSR OH1		; for 16-bit bytes
OH1    JSR OH2
OH2    ASL
       ADC #0
       ASL
       ADC #0
       ASL
       ADC #0
       ASL
       ADC #0
       PHA
       AND #$0F
       CMP #$0A
       BCC OH3
       ADC #$66
OH3    EOR #$30
       putc
       PLA
       RTS
OUTHSP JSR OUTHEX
       LDA #$20
OA1    putc
       RTS
OUTCR  LDA #$0D
       putc
       LDA #$0A
       BNE OA1        ;always

Lnmi:
        .byte 1,2
 
Lreset:
        .word init
Lirqbrk:
        .byte 5,6
Lend:
